<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deki TTS</title>
    <link rel="icon" href="shortcut.png" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .spinner {
            border-top-color: #4f46e5;
            /* indigo-600 */
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Style for the audio player in dark mode */
        audio::-webkit-media-controls-panel {
            background-color: #374151;
            /* gray-700 */
        }

        audio::-webkit-media-controls-play-button,
        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display,
        audio::-webkit-media-controls-timeline,
        audio::-webkit-media-controls-volume-slider,
        audio::-webkit-media-controls-fullscreen-button {
            filter: invert(1);
        }

        kbd {
            background-color: #374151;
            border-radius: 3px;
            border: 1px solid #4b5563;
            padding: 2px 4px;
            font-size: 0.8em;
            margin-left: 8px;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 p-6 md:p-8 space-y-6">

        <!-- Header -->
        <div class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Anki Audio Generator</h1>
            <p class="text-gray-400 mt-2">Generate TTS for your flashcard sentences using your preferred ElevenLabs
                model.</p>
        </div>

        <!-- Configuration Section -->
        <div class="p-6 bg-gray-900/50 rounded-xl border border-gray-700">
            <div class="text-center">
                <label for="fileInput" class="block text-sm font-medium text-gray-400 mb-2">1. Select your Anki Export
                    File (.txt or .tsv)</label>
                <input type="file" id="fileInput" accept=".txt,.tsv,text/plain,text/tab-separated-values" multiple
                    class="w-full max-w-sm mx-auto text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:font-semibold file:bg-indigo-500/10 file:text-indigo-400 hover:file:bg-indigo-500/20 file:border-gray-600">
            </div>
            <div class="mt-4">
                <div class="text-center">
                    <span class="block text-sm font-medium text-gray-400 mb-2">2. Choose a Voice Mode</span>
                    <p class="text-xs text-gray-500">Pick a mode below. Voice IDs are fixed for each language.</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700">
                        <input type="radio" name="voiceMode" id="voiceModeA" value="voiceA"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500" checked>
                        <div class="flex-1 text-left">
                            <label for="voiceModeA" class="text-sm font-semibold text-gray-200">Deutsch</label>
                            <p class="text-xs text-gray-400 mb-2">Default German voice used so far.</p>
                            <p class="text-xs text-gray-500">Voice ID:
                                <span class="font-mono text-gray-400">FOfJ2PMgU6HOGbNYnzto</span>
                            </p>
                        </div>
                    </div>
                    <div class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700">
                        <input type="radio" name="voiceMode" id="voiceModeB" value="voiceB"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500">
                        <div class="flex-1 text-left">
                            <label for="voiceModeB" class="text-sm font-semibold text-gray-200">Englisch</label>
                            <p class="text-xs text-gray-400 mb-2">Use this when you want the English voice.</p>
                            <p class="text-xs text-gray-500">Voice ID:
                                <span class="font-mono text-gray-400">XrExE9yKIg1WjnnlVkGX</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-6">
                <div class="text-center">
                    <span class="block text-sm font-medium text-gray-400 mb-2">3. Choose a TTS Model</span>
                    <p class="text-xs text-gray-500">Stick with the stable Multilingual v2 model or try the newer v3
                        alpha.</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <label for="modelModeV2"
                        class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700 cursor-pointer">
                        <input type="radio" name="modelMode" id="modelModeV2" value="eleven_multilingual_v2"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500" checked>
                        <div>
                            <p class="text-sm font-semibold text-gray-200">Multilingual v2 (Stable)</p>
                            <p class="text-xs text-gray-400 mb-2">Current production-ready model from ElevenLabs.</p>
                            <p class="text-xs text-gray-500">Model ID:
                                <span class="font-mono text-gray-400">eleven_multilingual_v2</span>
                            </p>
                        </div>
                    </label>
                    <label for="modelModeV3"
                        class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700 cursor-pointer">
                        <input type="radio" name="modelMode" id="modelModeV3" value="eleven_v3"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500">
                        <div>
                            <p class="text-sm font-semibold text-gray-200">Eleven v3 Alpha (Latest)</p>
                            <p class="text-xs text-gray-400 mb-2">Experimental alpha release with the newest upgrades.
                            </p>
                            <p class="text-xs text-gray-500">Model ID:
                                <span class="font-mono text-gray-400">eleven_v3</span>
                            </p>
                        </div>
                    </label>
                </div>
            </div>
            <div class="mt-6">
                <div class="text-center">
                    <span class="block text-sm font-medium text-gray-400 mb-2">4. Choose What to Generate</span>
                    <p class="text-xs text-gray-500">Switch between example sentences, single-word pronunciations, or
                        alternating both.</p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <label for="generationModeSentences"
                        class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700 cursor-pointer">
                        <input type="radio" name="generationMode" id="generationModeSentences" value="sentences"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500" checked>
                        <div>
                            <p class="text-sm font-semibold text-gray-200">Example Sentences</p>
                            <p class="text-xs text-gray-400">Generate audio for the sentence field (fourth column with
                                &lt;br&gt; separated examples).</p>
                        </div>
                    </label>
                    <label for="generationModeWords"
                        class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700 cursor-pointer">
                        <input type="radio" name="generationMode" id="generationModeWords" value="words"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500">
                        <div>
                            <p class="text-sm font-semibold text-gray-200">Words Only</p>
                            <p class="text-xs text-gray-400">Generate audio for the vocabulary term (second column) with
                                one clip per card.</p>
                        </div>
                    </label>
                    <label for="generationModeBoth"
                        class="flex items-start space-x-3 bg-gray-900/60 p-4 rounded-lg border border-gray-700 cursor-pointer">
                        <input type="radio" name="generationMode" id="generationModeBoth" value="both"
                            class="mt-1.5 h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500">
                        <div>
                            <p class="text-sm font-semibold text-gray-200">Word + Sentence Loop</p>
                            <p class="text-xs text-gray-400">Generate the term first, then each example sentence before
                                moving to the next card.</p>
                        </div>
                    </label>
                </div>
            </div>
            <div class="mt-6">
                <label class="block text-sm font-medium text-gray-400 mb-2 text-center">4. Choose an API Account</label>
                <div class="bg-gray-900/60 p-4 rounded-lg border border-gray-700 space-y-3">
                    <div id="accountList" class="space-y-3"></div>
                    <p id="accountMessage" class="text-xs text-center text-gray-500">Loading account balances...</p>
                </div>
            </div>
            <div class="text-center mt-6">
                <label class="block text-sm font-medium text-gray-400 mb-2">5. Start the Process</label>
                <button id="loadFileBtn"
                    class="w-full max-w-sm mx-auto bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">
                    Load File & Start
                </button>
            </div>
        </div>

        <!-- Main Workspace -->
        <div id="workspace" class="hidden space-y-6">
            <!-- Progress & Status -->
            <div class="space-y-2">
                <div class="flex justify-between items-center mb-1">
                    <span class="text-sm font-medium text-gray-400">Progress</span>
                    <span id="progressCounter" class="text-sm font-medium text-gray-400">0 / 0</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <div id="statusLog" class="text-center text-sm text-gray-400 h-5"></div>
            </div>

            <!-- Current Item -->
            <div class="bg-gray-900/50 p-6 rounded-xl border border-gray-700 text-center space-y-4">
                <div>
                    <p class="text-sm text-gray-400">Current Word</p>
                    <h2 id="currentWord" class="text-2xl font-bold text-indigo-400">-</h2>
                </div>
                <div>
                    <p id="currentTextLabel" class="text-sm text-gray-400">Sentence to Generate</p>
                    <p id="currentText" class="text-lg font-medium text-gray-100">-</p>
                </div>
                <audio id="audioPlayer" controls class="w-full mt-4 hidden"></audio>
            </div>

            <!-- Action Buttons -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <button id="generateBtn"
                    class="bg-blue-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105">Generate<kbd>G</kbd></button>
                <button id="regenerateBtn"
                    class="bg-yellow-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500 transition-transform transform hover:scale-105 btn-disabled"
                    disabled>Regenerate<kbd>R</kbd></button>
                <button id="approveBtn"
                    class="bg-green-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-transform transform hover:scale-105 btn-disabled"
                    disabled>Approve<kbd>A</kbd></button>
                <button id="skipBtn"
                    class="bg-red-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-transform transform hover:scale-105">Skip<kbd>S</kbd></button>
            </div>

            <!-- Download Section -->
            <div class="text-center pt-4">
                <button id="downloadZipBtn"
                    class="w-full md:w-1/2 bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform transform hover:scale-105 btn-disabled"
                    disabled>
                    Download All Approved as ZIP (<span id="zipCount">0</span> files)
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- Hardcoded User Settings ---
        const API_ACCOUNTS = [
            {
                id: 'account-1',
                name: 'Howard',
                email: 'suitor_jollier9k@icloud.com',
                apiKey: 'sk_ddfc786e0ce60cca7d9f45fc969f156f683595a7c729f632'
            },
            {
                id: 'account-2',
                name: 'Jesse',
                email: 'salsas-beleuchtet75@icloud.com',
                apiKey: 'sk_6f322f7ed4274e779096fec1fdc987d4995657938247a143'
            },
            {
                id: 'account-3',
                name: 'Hank',
                email: 'collars_indigo4j@icloud.com',
                apiKey: 'sk_9123fb529a0006c6629635626837afa1326a976018e07b35'
            },
            {
                id: 'account-4',
                name: 'Nacho',
                email: 'fauna.gustier3x@icloud.com',
                apiKey: 'sk_fce14447c3c5e8cda274009f0e2f2d8d712f0161e47decf2'
            },
            {
                id: 'account-5',
                name: 'Saul',
                email: 'zehntel.idyll.5m@icloud.com',
                apiKey: 'sk_012257205d1797a530d95f36e26b5707932e8942055ddfa2'
            }
        ];
        const VOICE_IDS = {
            voiceA: "FOfJ2PMgU6HOGbNYnzto",
            voiceB: "XrExE9yKIg1WjnnlVkGX"
        };
        const DEFAULT_TTS_MODEL_ID = 'eleven_multilingual_v2';

        // DOM Elements
        const fileInput = document.getElementById('fileInput');
        const loadFileBtn = document.getElementById('loadFileBtn');
        const workspace = document.getElementById('workspace');
        const progressCounter = document.getElementById('progressCounter');
        const progressBar = document.getElementById('progressBar');
        const statusLog = document.getElementById('statusLog');
        const currentWordEl = document.getElementById('currentWord');
        const currentTextEl = document.getElementById('currentText');
        const currentTextLabelEl = document.getElementById('currentTextLabel');
        const audioPlayer = document.getElementById('audioPlayer');
        const generateBtn = document.getElementById('generateBtn');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const approveBtn = document.getElementById('approveBtn');
        const skipBtn = document.getElementById('skipBtn');
        const downloadZipBtn = document.getElementById('downloadZipBtn');
        const zipCount = document.getElementById('zipCount');
        const generationModeRadios = document.querySelectorAll('input[name="generationMode"]');
        const accountListEl = document.getElementById('accountList');
        const accountMessageEl = document.getElementById('accountMessage');

        // App State
        let allRows = [];
        let currentRowIndex = 0;
        let currentSentenceIndex = 0;
        let lastGeneratedBlob = null;
        let generationMode = 'sentences';
        const approvedAudioBlobs = new Map();
        const BALANCE_REFRESH_INTERVAL_MS = 60000;
        let balanceRefreshTimerId = null;
        const accountElements = new Map();
        let selectedAccountId = null;

        // --- Event Listeners ---
        loadFileBtn.addEventListener('click', handleFileLoad);
        generateBtn.addEventListener('click', () => processGeneration(false));
        regenerateBtn.addEventListener('click', () => processGeneration(true));
        approveBtn.addEventListener('click', handleApprove);
        skipBtn.addEventListener('click', handleSkip);
        downloadZipBtn.addEventListener('click', downloadZip);
        document.addEventListener('keydown', handleKeyPress);
        generationModeRadios.forEach(radio => {
            radio.addEventListener('change', handleGenerationModeChange);
        });

        // --- Account Management ---

        function formatNumber(value) {
            return value.toLocaleString(undefined, { maximumFractionDigits: 0 });
        }

        function formatResetCountdown(targetDate) {
            if (!(targetDate instanceof Date) || Number.isNaN(targetDate.getTime())) {
                return null;
            }
            const diffMs = targetDate.getTime() - Date.now();
            if (diffMs <= 0) {
                return 'due now';
            }

            const totalMinutes = Math.floor(diffMs / 60000);
            if (totalMinutes < 1) {
                return 'in <1m';
            }
            if (totalMinutes < 60) {
                return `in ${totalMinutes}m`;
            }

            const totalHours = Math.floor(totalMinutes / 60);
            if (totalHours < 24) {
                return `in ${totalHours}h`;
            }

            const totalDays = Math.floor(totalHours / 24);
            const weeks = Math.floor(totalDays / 7);
            const days = totalDays % 7;
            const parts = [];

            if (weeks > 0) {
                parts.push(`${weeks}w`);
            }
            if (days > 0) {
                parts.push(`${days}d`);
            }

            if (parts.length === 0) {
                const remainingHours = totalHours % 24;
                if (remainingHours > 0) {
                    parts.push(`${remainingHours}h`);
                }
            }

            return parts.length > 0 ? `in ${parts.join(' ')}` : 'in <1d';
        }

        function maskApiKey(key) {
            if (!key) return '';
            const visible = 4;
            if (key.length <= visible * 2) return key;
            return `${key.slice(0, visible)}...${key.slice(-visible)}`;
        }

        function sanitizeFilenamePart(value) {
            if (!value) return 'entry';
            const cleaned = value
                .replace(/[^A-Za-z0-9 _-]/g, '')
                .trim()
                .replace(/\s+/g, '_');
            return cleaned || 'entry';
        }

        function getSentenceList(item) {
            if (!item) return [];
            return Array.isArray(item.sentences) ? item.sentences : [];
        }

        function getContentType(item, index = 0) {
            if (generationMode === 'words') return 'word';
            if (generationMode === 'sentences') return 'sentence';
            if (!item) return 'word';
            const hasWord = Boolean(item.word);
            if (hasWord && index <= 0) {
                return 'word';
            }
            const offset = hasWord ? 1 : 0;
            return index >= offset ? 'sentence' : 'word';
        }

        function getSentenceMeta(item, index) {
            const sentences = getSentenceList(item);
            if (sentences.length === 0) {
                return { total: 0, position: 0 };
            }

            if (generationMode === 'sentences') {
                return { total: sentences.length, position: index + 1 };
            }

            if (generationMode === 'both') {
                const hasWord = Boolean(item.word);
                const offset = hasWord ? 1 : 0;
                const position = index - offset + 1;
                return {
                    total: sentences.length,
                    position: Math.max(position, 1)
                };
            }

            return { total: sentences.length, position: 0 };
        }

        // --- Generation Helpers ---

        function getContentLength(item) {
            if (!item) return 0;
            if (generationMode === 'words') {
                return item.word ? 1 : 0;
            }
            if (generationMode === 'sentences') {
                return getSentenceList(item).length;
            }
            const sentenceCount = getSentenceList(item).length;
            return (item.word ? 1 : 0) + sentenceCount;
        }

        function getContentAt(item, index) {
            if (!item) return '';
            if (generationMode === 'words') {
                return item.word || '';
            }
            if (generationMode === 'sentences') {
                const sentences = getSentenceList(item);
                return sentences[index] || '';
            }
            const hasWord = Boolean(item.word);
            if (hasWord) {
                if (index === 0) {
                    return item.word || '';
                }
                index -= 1;
            }
            const sentences = getSentenceList(item);
            return sentences[index] || '';
        }

        function getTotalItems() {
            if (!Array.isArray(allRows) || allRows.length === 0) return 0;
            return allRows.reduce((sum, row) => sum + getContentLength(row), 0);
        }

        function getProcessedItemCount() {
            if (!Array.isArray(allRows) || allRows.length === 0) return 0;
            const cappedRowIndex = Math.min(currentRowIndex, allRows.length);
            let count = 0;
            for (let i = 0; i < cappedRowIndex; i++) {
                count += getContentLength(allRows[i]);
            }
            const currentRow = allRows[currentRowIndex];
            if (!currentRow) {
                return getTotalItems();
            }
            const currentLength = getContentLength(currentRow);
            return count + Math.min(currentSentenceIndex, currentLength);
        }

        function ensureValidPosition() {
            while (currentRowIndex < allRows.length) {
                const length = getContentLength(allRows[currentRowIndex]);
                if (length === 0) {
                    currentRowIndex++;
                    currentSentenceIndex = 0;
                    continue;
                }
                if (currentSentenceIndex >= length) {
                    currentSentenceIndex = 0;
                    continue;
                }
                break;
            }
        }

        function initializeAccountSelector() {
            const previouslySelected = selectedAccountId;
            accountElements.clear();
            if (accountListEl) {
                accountListEl.innerHTML = '';
            }

            if (!Array.isArray(API_ACCOUNTS) || API_ACCOUNTS.length === 0) {
                selectedAccountId = null;
                if (accountMessageEl) {
                    accountMessageEl.textContent = 'Add your ElevenLabs API keys in the script to track balances.';
                }
                return;
            }

            let firstSelectableId = null;

            API_ACCOUNTS.forEach((account, index) => {
                const wrapper = document.createElement('label');
                wrapper.className = 'flex items-center justify-between bg-gray-900/80 border border-gray-700 rounded-lg p-3 gap-4 transition-shadow';
                wrapper.dataset.accountId = account.id;

                const left = document.createElement('div');
                left.className = 'flex items-center space-x-3';

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'apiAccount';
                radio.value = account.id;
                radio.className = 'h-4 w-4 text-indigo-500 border-gray-600 focus:ring-indigo-500';

                if (!account.apiKey) {
                    radio.disabled = true;
                } else if (!firstSelectableId) {
                    firstSelectableId = account.id;
                }

                const textContainer = document.createElement('div');

                const nameEl = document.createElement('p');
                nameEl.className = 'text-sm font-semibold text-gray-200';
                nameEl.textContent = account.name || `Account ${index + 1}`;

                const keyEl = document.createElement('p');
                keyEl.className = 'text-xs text-gray-500';
                keyEl.textContent = account.apiKey ? `Key: ${maskApiKey(account.apiKey)}` : 'Add an API key to enable this account.';

                textContainer.appendChild(nameEl);
                textContainer.appendChild(keyEl);
                const emailEl = document.createElement('p');
                emailEl.className = 'text-xs text-gray-500';
                emailEl.textContent = account.email ? `Email: ${account.email}` : 'Email not provided.';
                textContainer.appendChild(emailEl);

                left.appendChild(radio);
                left.appendChild(textContainer);

                const right = document.createElement('div');
                right.className = 'text-right';

                const remainingEl = document.createElement('p');
                remainingEl.className = 'text-sm font-semibold text-indigo-400';
                remainingEl.textContent = '--';

                const statusEl = document.createElement('p');
                statusEl.className = 'text-xs text-gray-500';
                statusEl.textContent = account.apiKey ? 'Waiting to refresh...' : 'Disabled';

                right.appendChild(remainingEl);
                right.appendChild(statusEl);

                wrapper.appendChild(left);
                wrapper.appendChild(right);

                if (accountListEl) {
                    accountListEl.appendChild(wrapper);
                }

                accountElements.set(account.id, { radioEl: radio, remainingEl, statusEl, wrapperEl: wrapper, account });

                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        setSelectedAccount(account.id);
                    }
                });
            });

            let nextSelectedId = previouslySelected && accountElements.has(previouslySelected)
                ? previouslySelected
                : null;

            if (nextSelectedId) {
                const account = API_ACCOUNTS.find(acc => acc.id === nextSelectedId);
                if (!account || !account.apiKey) {
                    nextSelectedId = null;
                }
            }

            if (!nextSelectedId) {
                nextSelectedId = firstSelectableId || null;
            }

            setSelectedAccount(nextSelectedId);

            if (accountMessageEl) {
                if (firstSelectableId) {
                    accountMessageEl.textContent = 'Balances refresh automatically every minute.';
                } else {
                    accountMessageEl.textContent = 'Add API keys to enable account selection.';
                }
            }
        }

        function setSelectedAccount(accountId) {
            selectedAccountId = accountId || null;
            accountElements.forEach(({ radioEl, wrapperEl, account }) => {
                const isSelected = accountId !== null && account.id === accountId;
                if (radioEl) {
                    radioEl.checked = isSelected;
                }
                if (wrapperEl) {
                    wrapperEl.classList.toggle('border-indigo-500', isSelected);
                    wrapperEl.classList.toggle('shadow-lg', isSelected);
                }
            });
        }

        function getSelectedAccount() {
            if (!selectedAccountId) return null;
            return API_ACCOUNTS.find(account => account.id === selectedAccountId) || null;
        }

        async function refreshAccountBalance(account, options = {}) {
            const { silent = false } = options;
            const elements = accountElements.get(account.id);
            if (!elements) return;

            const { remainingEl, statusEl } = elements;

            if (!account.apiKey) {
                remainingEl.textContent = '--';
                statusEl.textContent = 'No API key configured.';
                return;
            }

            if (!silent) {
                statusEl.textContent = 'Checking balance...';
            }

            try {
                const response = await fetch('https://api.elevenlabs.io/v1/user/subscription', {
                    headers: {
                        Accept: 'application/json',
                        'xi-api-key': account.apiKey
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                const subscription = data && typeof data === 'object'
                    ? (data.subscription && typeof data.subscription === 'object' ? data.subscription : data)
                    : {};

                let remaining;
                const limit = typeof subscription.character_limit === 'number'
                    ? subscription.character_limit
                    : (typeof data?.character_limit === 'number' ? data.character_limit : undefined);
                const used = typeof subscription.character_count === 'number'
                    ? subscription.character_count
                    : (typeof data?.character_count === 'number' ? data.character_count : undefined);

                if (typeof limit === 'number' && typeof used === 'number') {
                    remaining = Math.max(limit - used, 0);
                }
                if (remaining === undefined && typeof subscription.characters_left === 'number') {
                    remaining = subscription.characters_left;
                }
                if (remaining === undefined && typeof subscription.available_characters === 'number') {
                    remaining = subscription.available_characters;
                }

                const resetUnix = typeof subscription.next_character_count_reset_unix === 'number'
                    ? subscription.next_character_count_reset_unix
                    : (typeof data?.next_character_count_reset_unix === 'number' ? data.next_character_count_reset_unix : undefined);
                const resetIso = typeof subscription.next_character_count_reset === 'string'
                    ? subscription.next_character_count_reset
                    : (typeof data?.next_character_count_reset === 'string' ? data.next_character_count_reset : undefined);

                let nextResetDate = null;
                if (typeof resetUnix === 'number') {
                    nextResetDate = new Date(resetUnix * 1000);
                } else if (resetIso) {
                    const parsedReset = new Date(resetIso);
                    if (!Number.isNaN(parsedReset.getTime())) {
                        nextResetDate = parsedReset;
                    }
                }

                const updateText = `Updated ${new Date().toLocaleTimeString()}`;
                const resetText = nextResetDate
                    ? `Resets ${nextResetDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' })}`
                    : null;
                const resetRelative = nextResetDate ? formatResetCountdown(nextResetDate) : null;
                const combinedStatus = [updateText, resetText, resetRelative].filter(Boolean).join(' Â· ');

                if (remaining !== undefined) {
                    remainingEl.textContent = formatNumber(remaining);
                    statusEl.textContent = combinedStatus || updateText;
                } else {
                    remainingEl.textContent = '--';
                    statusEl.textContent = ['Balance format unexpected.', combinedStatus].filter(Boolean).join(' ');
                }
            } catch (error) {
                const message = error && error.message ? error.message : 'Unknown error';
                remainingEl.textContent = '--';
                statusEl.textContent = `Could not load balance (${message}).`;
            }
        }

        function refreshAllAccountBalances(options = {}) {
            return Promise.all(API_ACCOUNTS.map(account => refreshAccountBalance(account, options)));
        }

        function startBalanceAutoRefresh() {
            initializeAccountSelector();
            refreshAllAccountBalances().catch(() => { /* handled per account */ });
            if (balanceRefreshTimerId) {
                clearInterval(balanceRefreshTimerId);
            }
            balanceRefreshTimerId = setInterval(() => {
                refreshAllAccountBalances({ silent: true });
            }, BALANCE_REFRESH_INTERVAL_MS);
        }

        startBalanceAutoRefresh();

        // --- Core Functions ---

        function handleKeyPress(event) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
            switch (event.key.toLowerCase()) {
                case 'g': if (!generateBtn.disabled) generateBtn.click(); break;
                case 'r': if (!regenerateBtn.disabled) regenerateBtn.click(); break;
                case 'a': if (!approveBtn.disabled) approveBtn.click(); break;
                case 's': if (!skipBtn.disabled) skipBtn.click(); break;
            }
        }

        function getSelectedVoiceId() {
            const selectedRadio = document.querySelector('input[name="voiceMode"]:checked');
            const selectedMode = selectedRadio ? selectedRadio.value : 'voiceA';
            return VOICE_IDS[selectedMode] || VOICE_IDS.voiceA;
        }

        function getSelectedModelId() {
            const selectedModelRadio = document.querySelector('input[name="modelMode"]:checked');
            return selectedModelRadio ? selectedModelRadio.value : DEFAULT_TTS_MODEL_ID;
        }

        function handleGenerationModeChange(event) {
            const { value } = event.target;
            if (!value || value === generationMode) return;

            generationMode = value;
            currentRowIndex = 0;
            currentSentenceIndex = 0;
            lastGeneratedBlob = null;
            setLoadingState(false);
            updateButtons(false);
            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';

            ensureValidPosition();
            updateUIForCurrentItem();

            if (!Array.isArray(allRows) || allRows.length === 0) {
                return;
            }

            const totalItems = getTotalItems();
            if (totalItems === 0) {
                let emptyMessage;
                if (generationMode === 'words') {
                    emptyMessage = 'Words mode is ready, but no terms were found in the second column.';
                } else if (generationMode === 'sentences') {
                    emptyMessage = 'Sentence mode is ready, but no example sentences were found in the fourth column.';
                } else {
                    emptyMessage = 'Combined mode is ready, but no terms or example sentences were found.';
                }
                updateStatus(emptyMessage, 'info');
            } else {
                let modeMessage;
                if (generationMode === 'words') {
                    modeMessage = 'Switched to word pronunciation mode.';
                } else if (generationMode === 'sentences') {
                    modeMessage = 'Switched to example sentence mode.';
                } else {
                    modeMessage = 'Switched to alternating word and sentence mode.';
                }
                updateStatus(modeMessage, 'info');
            }
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve(event.target.result);
                reader.onerror = () => reject(new Error(`Failed to read ${file.name}.`));
                reader.readAsText(file, 'UTF-8');
            });
        }

        async function handleFileLoad() {
            const files = Array.from(fileInput.files || []);
            if (files.length === 0) {
                updateStatus('Please select a file to load.', 'error');
                return;
            }

            updateStatus(files.length === 1 ? 'Loading file...' : `Loading ${files.length} files...`, 'loading');

            let combinedRows = [];
            try {
                const contents = await Promise.all(files.map(readFileAsText));
                combinedRows = contents.flatMap(parseFileContent);
            } catch (error) {
                console.error(error);
                updateStatus(error.message || 'Failed to read the selected files.', 'error');
                return;
            }

            allRows = combinedRows;
            currentRowIndex = 0;
            currentSentenceIndex = 0;
            lastGeneratedBlob = null;
            setLoadingState(false);
            updateButtons(false);
            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';

            approvedAudioBlobs.clear();
            zipCount.textContent = approvedAudioBlobs.size;
            downloadZipBtn.disabled = true;
            downloadZipBtn.classList.add('btn-disabled');

            if (allRows.length === 0) {
                workspace.classList.add('hidden');
                updateStatus('File is empty or could not be parsed.', 'error');
                updateProgress();
                return;
            }

            ensureValidPosition();
            workspace.classList.remove('hidden');
            updateUIForCurrentItem();

            const totalItems = getTotalItems();
            if (totalItems > 0) {
                const successMessage = files.length === 1
                    ? 'File loaded. Ready to generate.'
                    : `${files.length} files loaded. Ready to generate.`;
                updateStatus(successMessage, 'success');
            } else {
                let infoMessage;
                if (generationMode === 'words') {
                    infoMessage = 'File loaded, but no vocabulary terms were detected in the second column.';
                } else if (generationMode === 'sentences') {
                    infoMessage = 'File loaded, but no example sentences were detected in the fourth column.';
                } else {
                    infoMessage = 'File loaded, but no vocabulary terms or example sentences were detected in the required columns.';
                }
                updateStatus(infoMessage, 'info');
            }
        }

        function parseFileContent(content) {
            const rows = [];
            const lines = content.split('\n');
            lines.forEach(line => {
                const columns = line.split('\t');
                if (columns.length < 2) return;
                const termCandidate = columns[1] !== undefined ? columns[1] : columns[0];
                const germanWord = (termCandidate || '').trim();
                const sentencesRaw = (columns[3] || '').trim();
                const sentences = sentencesRaw
                    ? sentencesRaw.split('<br>').map(s => s.trim()).filter(Boolean)
                    : [];
                if (!germanWord) return;
                rows.push({ word: germanWord, sentences });
            });
            return rows;
        }

        function updateUIForCurrentItem() {
            const totalItems = getTotalItems();

            if (totalItems === 0) {
                if (currentTextLabelEl) {
                    const label = generationMode === 'words'
                        ? 'Word to Generate'
                        : (generationMode === 'sentences' ? 'Sentence to Generate' : 'Word or Sentence to Generate');
                    currentTextLabelEl.textContent = label;
                }
                currentWordEl.textContent = 'No content available';
                let helperText;
                if (generationMode === 'words') {
                    helperText = 'Load an export with vocabulary terms in the second column.';
                } else if (generationMode === 'sentences') {
                    helperText = 'Load an export with example sentences in the fourth column.';
                } else {
                    helperText = 'Load an export with vocabulary terms in the second column and example sentences in the fourth column.';
                }
                currentTextEl.textContent = helperText;
                audioPlayer.classList.add('hidden');
                audioPlayer.src = '';
                lastGeneratedBlob = null;
                disableAllActionButtons();
                updateProgress();
                return;
            }

            ensureValidPosition();

            if (currentRowIndex >= allRows.length) {
                currentWordEl.textContent = 'All Done!';
                currentTextEl.textContent = 'You have processed all items.';
                audioPlayer.classList.add('hidden');
                audioPlayer.src = '';
                lastGeneratedBlob = null;
                disableAllActionButtons();
                updateStatus('Congratulations! You finished the list.', 'success');
                updateProgress();
                return;
            }

            const currentItem = allRows[currentRowIndex];
            const contentType = getContentType(currentItem, currentSentenceIndex);
            if (currentTextLabelEl) {
                currentTextLabelEl.textContent = contentType === 'sentence' ? 'Sentence to Generate' : 'Word to Generate';
            }
            const currentTextValue = getContentAt(currentItem, currentSentenceIndex) || '';
            let wordDisplay = currentItem.word || `Entry ${currentRowIndex + 1}`;
            if (contentType === 'sentence') {
                const { total, position } = getSentenceMeta(currentItem, currentSentenceIndex);
                if (total > 1) {
                    wordDisplay += ` (${position}/${total})`;
                }
            }
            currentWordEl.textContent = wordDisplay;
            currentTextEl.textContent = currentTextValue;

            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';
            lastGeneratedBlob = null;

            updateButtons(false);
            skipBtn.disabled = false;
            skipBtn.classList.remove('btn-disabled');
            updateProgress();
        }

        async function processGeneration(isRegen) {
            ensureValidPosition();
            if (currentRowIndex >= allRows.length) {
                updateStatus('No items available to generate.', 'error');
                return;
            }

            const currentItem = allRows[currentRowIndex];
            const rawText = getContentAt(currentItem, currentSentenceIndex);
            if (!rawText) {
                updateStatus('No text available for this entry.', 'error');
                return;
            }

            const textToGenerate = rawText.trim();
            if (!textToGenerate) {
                updateStatus('Text is empty after trimming.', 'error');
                return;
            }

            const voiceId = getSelectedVoiceId();
            if (!voiceId) {
                updateStatus('Voice ID missing for the selected voice mode.', 'error');
                return;
            }

            const activeAccount = getSelectedAccount();
            if (!activeAccount || !activeAccount.apiKey) {
                updateStatus('Select an API account with a valid key before generating.', 'error');
                return;
            }

            const contentType = getContentType(currentItem, currentSentenceIndex);
            const speedSetting = contentType === 'sentence' ? 0.80 : 0.70;
            const payload = {
                "text": textToGenerate,
                "model_id": getSelectedModelId(),
                "voice_settings": {
                    "stability": 0.5,
                    "similarity_boost": 0.75,
                    "style": 0.0,
                    "use_speaker_boost": true,
                    "speed": speedSetting
                }
            };

            updateStatus(isRegen ? 'Regenerating audio...' : 'Generating audio...', 'loading');
            setLoadingState(true);

            const TTS_URL = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`;
            const headers = {
                "Accept": "audio/mpeg",
                "Content-Type": "application/json",
                "xi-api-key": activeAccount.apiKey
            };

            try {
                const response = await fetch(TTS_URL, { method: 'POST', headers, body: JSON.stringify(payload) });
                if (response.ok) {
                    const blob = await response.blob();
                    lastGeneratedBlob = blob;
                    const audioUrl = URL.createObjectURL(blob);
                    audioPlayer.src = audioUrl;
                    audioPlayer.classList.remove('hidden');
                    audioPlayer.play();
                    updateStatus('Audio generated. Please review.', 'success');
                    updateButtons(true);
                    refreshAccountBalance(activeAccount, { silent: true });
                } else {
                    const errorData = await response.json();
                    const errorMessage = errorData.detail ? errorData.detail.message : 'An unknown API error occurred.';
                    updateStatus(`Error: ${errorMessage}`, 'error');
                    updateButtons(false);
                }
            } catch (error) {
                updateStatus(`Network Error: ${error.message}`, 'error');
            } finally {
                setLoadingState(false);
            }
        }

        function handleApprove() {
            if (currentRowIndex >= allRows.length) {
                updateStatus('Nothing to approve.', 'error');
                return;
            }

            const currentItem = allRows[currentRowIndex];
            const textValue = getContentAt(currentItem, currentSentenceIndex);
            if (!textValue) {
                updateStatus('Nothing to approve for this entry.', 'error');
                return;
            }

            const rawBaseName = currentItem.word || `entry_${currentRowIndex + 1}`;
            const sanitizedBase = sanitizeFilenamePart(rawBaseName);
            const contentType = getContentType(currentItem, currentSentenceIndex);

            let filenameBase;
            if (contentType === 'word') {
                filenameBase = sanitizedBase;
            } else {
                const { total, position } = getSentenceMeta(currentItem, currentSentenceIndex);
                const suffix = total > 1 && position > 1 ? position.toString() : '';
                filenameBase = `s_${sanitizedBase}${suffix}`;
            }

            const filename = `${filenameBase}.mp3`;

            if (lastGeneratedBlob) {
                approvedAudioBlobs.set(filename, lastGeneratedBlob);
                updateStatus(`Approved and saved: ${filename}`, 'success');
                zipCount.textContent = approvedAudioBlobs.size;
                downloadZipBtn.disabled = false;
                downloadZipBtn.classList.remove('btn-disabled');
            } else {
                updateStatus('Generate audio before approving.', 'error');
            }

            // Move to the next sentence or word
            moveToNextItem();
        }

        function handleSkip() {
            const currentItem = allRows[currentRowIndex];
            const contentType = getContentType(currentItem, currentSentenceIndex);
            const label = contentType === 'sentence' ? 'sentence' : 'word';
            updateStatus(`Skipped ${label}`, 'info');
            moveToNextItem();
        }

        function moveToNextItem() {
            if (allRows.length === 0) return;

            const currentItem = allRows[currentRowIndex];
            const contentLength = getContentLength(currentItem);

            if (contentLength === 0) {
                currentRowIndex++;
                currentSentenceIndex = 0;
            } else {
                currentSentenceIndex++;
                if (currentSentenceIndex >= contentLength) {
                    currentRowIndex++;
                    currentSentenceIndex = 0;
                }
            }

            ensureValidPosition();
            updateUIForCurrentItem();
        }

        async function downloadZip() {
            if (approvedAudioBlobs.size === 0) {
                updateStatus('No approved audio files to download.', 'error');
                return;
            }
            updateStatus('Creating ZIP file... please wait.', 'loading');
            const zip = new JSZip();
            approvedAudioBlobs.forEach((blob, filename) => {
                zip.file(filename, blob);
            });
            try {
                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, "anki_audio_files.zip");
                updateStatus('ZIP file downloaded successfully!', 'success');
            } catch (error) {
                updateStatus(`Error creating ZIP: ${error.message}`, 'error');
            }
        }

        // --- UI Helper Functions ---
        function updateStatus(message, type = 'info') {
            statusLog.textContent = message;
            statusLog.classList.remove('text-red-500', 'text-green-500', 'text-blue-500', 'text-yellow-400');
            if (type === 'error') statusLog.classList.add('text-red-500');
            if (type === 'success') statusLog.classList.add('text-green-500');
            if (type === 'loading') statusLog.classList.add('text-blue-500');
            if (type === 'info') statusLog.classList.add('text-yellow-400');
        }

        function updateButtons(isGenerated) {
            generateBtn.disabled = isGenerated;
            generateBtn.classList.toggle('btn-disabled', isGenerated);
            regenerateBtn.disabled = !isGenerated;
            regenerateBtn.classList.toggle('btn-disabled', !isGenerated);
            approveBtn.disabled = !isGenerated;
            approveBtn.classList.toggle('btn-disabled', !isGenerated);
        }

        function disableAllActionButtons() {
            [generateBtn, regenerateBtn, approveBtn, skipBtn].forEach(btn => {
                btn.disabled = true;
                btn.classList.add('btn-disabled');
            });
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                generateBtn.innerHTML = `<div class="spinner w-5 h-5 mx-auto border-2 border-gray-400 rounded-full"></div>`;
                generateBtn.disabled = true;
                generateBtn.classList.add('btn-disabled');
            } else {
                generateBtn.innerHTML = 'Generate<kbd>G</kbd>';
            }
        }

        function updateProgress() {
            const totalItems = getTotalItems();
            if (totalItems === 0) {
                progressCounter.textContent = '0 / 0';
                progressBar.style.width = '0%';
                return;
            }

            const processedItems = Math.min(getProcessedItemCount(), totalItems);
            const displayCurrent = Math.min(processedItems + 1, totalItems);

            progressCounter.textContent = `${displayCurrent} / ${totalItems}`;
            const percentage = (processedItems / totalItems) * 100;
            progressBar.style.width = `${percentage}%`;
        }
    </script>
</body>

</html>
